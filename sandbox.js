/** 4. Write a function that takes in a non-empty array of distinct integers and an
 * integer representing a target sum. If any two numbers in the input array sum
 * up to the target sum, the function should return them in an array, in any
 * order. If no two numbers sum up to the target sum, the function should return
 * an empty array. Note that the target sum has to be obtained by summing two
 * different integers in the array; you can't add a single integer to itself in
 * order to obtain the target sum. You can assume that there will be at most one
 * pair of numbers summing up to the target sum. */

function twoNumberSum(array, target) {}

/** 5. Given two non-empty arrays of integers, write a function that determines
 * whether the second array is a subsequence of the first one. A subsequence of
 * an array is a set of numbers that aren't necessarily adjacent in the array
 * but that are in the same order as they appear in the array. For instance, the
 * numbers [1, 3, 4] form a subsequence of the array [1, 2, 3, 4], and so do the
 * numbers [2, 4]. Note that a single number in an array and the array itself
 * are both valid subsequences of the array. */

function isValidSubsequence(array, sequence) {}

/** 6. Write a function that takes in a non-empty array of integers that are sorted
 * in ascending order and returns a new array of the same length with the
 * squares of the original integers also sorted in ascending order. */

function sortedSquaresArray(array) {}

/** 7. Write a function that takes in a Binary Search Tree (BST) and a target
 * integer value and returns the closest value to that target value contained in
 * the BST. */

function findClosestValueInBst(tree, target) {}
